<!-- Назначение файла: документация проекта и общие инструкции. -->

# Telegram Task Manager Bot + Mini App

[![Docker CI](https://github.com/AgroxOD/agrmcs/actions/workflows/docker.yml/badge.svg)](https://github.com/AgroxOD/agrmcs/actions/workflows/docker.yml)
[![Release](https://github.com/AgroxOD/agrmcs/actions/workflows/release.yml/badge.svg)](https://github.com/AgroxOD/agrmcs/actions/workflows/release.yml)
Файл описывает проект и способы его развертывания.

Каталог `bot` содержит код бота и статическое веб‑приложение Telegram.
Для сборки контейнера по умолчанию используется `bot/Dockerfile`; корневой `Dockerfile` нужен для единого образа без Compose.
Дополнительная информация о плане разработки представлена в файле `ROADMAP.md` (включая раздел «В разработке»), а история изменений ведётся в `CHANGELOG.md`.
За инструкцией по настройке команд и вебхуков бота обратитесь к файлу `docs/telegram_bot_manual.md`. Он описывает пошаговую работу с BotFather, проверку списка команд и скрипты `scripts/set_bot_commands.sh` и `scripts/set_bot_messages.sh`. Документация API приведена в `docs/api_reference.md` и доступна через `/api-docs`.
В том же руководстве раздел «Типовые ошибки API» демонстрирует пример `Bad Request: message text is empty` и реакцию бота после проверки аргументов.
Среди маршрутов API теперь есть `GET /api/tasks/:id` для получения одной задачи.
Также доступен скрипт `scripts/get_menu_button_url.js`, который выводит URL из кнопки меню или `/empty`, если используется поведение по умолчанию.
Для установки новой ссылки используется `scripts/set_menu_button_url.js`.
Для Attachment Menu создан скрипт `scripts/set_attachment_menu_url.js`, он указывает на страницу `/menu`.
Таблица всех ответов бота приведена в `docs/bot_responses.md`.
Пример результата со значениями из `.env.example`:
```
Ошибка: request to https://api.telegram.org/botyour_bot_token/getChatMenuButton failed, reason:
```
Карта запросов между API и базой описана в `docs/db_request_map.md`.
Документация по Tailwind-стилям Dashboard находится в `docs/dashboard_tailadmin.md`.
Отчёт Lighthouse за 24.06.2025 размещён в файле `docs/lighthouse_20250624.md`.
Свежий отчёт от 26.06.2025 доступен в `docs/lighthouse_20250626.md`.
Подробное руководство по всем элементам TailAdmin см. в `docs/extended_tailadmin_guide.md`.
Инструкция по созданию копии дизайна TailAdmin в Figma находится в `docs/tailadmin_figma_design.md`.
В последней версии обновлены основные зависимости сервера и клиента, что устранило
предупреждения npm о пакете `lodash.isequal` и других устаревших модулях.
Сам файл Figma помещён в `docs/TailAdminDesign.fig` и служит эталоном для верстки.
Файл в репозитории представляет собой заглушку. Полная версия дизайна находится во внешнем хранилище.

Дизайн полностью повторяет TailAdmin, но теперь используется только светлая тема для совместимости со всеми браузерами.

Файл `.env` исключён из репозитория. Создайте его локально на основе `.env.example`.

## Оглавление
- [Возможности](#возможности)
- [Быстрый старт](#быстрый-старт)
- [Миграции и сиды](#миграции-и-сиды)
- [Развёртывание на Railway](#развёртывание-на-railway)
- [Интерфейс](#интерфейс)
- [Напоминания о задачах](#напоминания-о-задачах)
- [Структура проекта](#структура-проекта)
- [Релизы](#релизы)
- [CI с Docker](#ci-с-docker)
- [Лучшие практики CI/CD](#лучшие-практики-ci-cd)
- [Внесение вклада](#внесение-вклада)
- [Безопасность](#безопасность)
- [Резервное копирование БД в R2](#резервное-копирование-бд-в-r2)
- [Загрузка вложений](#загрузка-вложений)
- [Обзор текущего состояния](#обзор-текущего-состояния)

## Возможности
- Управление задачами через Telegram‑бота и веб‑интерфейс
- Уведомления о событиях в чате Telegram
- Аутентификация пользователей через Telegram Login и JWT
- REST API для работы с задачами и пользователями

## Быстрый старт

### Требования

- Docker и Docker Compose
- Учётная запись MongoDB Atlas
- Node.js 20 или новее

### Локальный запуск

1. Склонируйте текущий репозиторий с модифицированным кодом:
   ```bash
   git clone https://github.com/AgroxOD/agrmcs.git
   ```
   Каталог `bot` уже содержит необходимые исходники.
2. Создайте файл `.env` на основе примера или существующих переменных окружения.
   Копирование примера:
   ```bash
   cp .env.example .env
   ```
   Автоматическая генерация:
   ```bash
    ./scripts/create_env_from_exports.sh
    ```
    Скрипт берёт список ключей из `.env.example`, подставляет значения из текущего
    окружения или оставляет дефолтные и создаёт файл. Напоминание: перед первым
    запуском обязательно выполните этот скрипт, чтобы не пропустить переменные.
    Сам файл `.env.example` содержит комментарии с описанием каждой переменной:
    где взять значение и для чего она нужна.
    В поле `MONGO_DATABASE_URL` укажите кластер
   `mongodb+srv://<user>:<pass>@arjs-db.4pzoyda.mongodb.net/agromarket`
   для работы с базой **agromarket**.
   Строка подключения должна начинаться с `mongodb://` или `mongodb+srv://`,
  иначе приложение завершит запуск с ошибкой.
  `.env` не хранится в репозитории и перечислен в `.gitignore`.
  В переменной `APP_URL` укажите HTTPS‑адрес мини‑приложения,
  иначе Telegram отклонит кнопку Web App.
  Модуль `bot/src/config.js` проверяет, что `APP_URL` начинается с `https://`,
  а `MONGO_DATABASE_URL` — с `mongodb://` или `mongodb+srv://`.
  Все переменные считываются централизованным модулем `bot/src/config.js`,
  который прекращает запуск при отсутствии обязательных значений.
  Если задать `WEBHOOK_URL`, бот включит режим webhook и зарегистрирует его через `setWebhook`.
  При наличии `BOT_API_URL` запросы Bot API будут отправляться на этот адрес вместо `https://api.telegram.org`.
  При запуске тестов также задайте `APP_URL`, иначе Jest завершится ошибкой.
  Для виджета входа необходимы `BOT_USERNAME` и `VITE_BOT_USERNAME` с юзернеймом бота.
  При их отсутствии в логах появится сообщение `VITE_BOT_USERNAME не задан`,
  а кнопка авторизации выдаст ошибку `Username invalid`.
  Для ссылки на обсуждение задач добавьте `VITE_CHAT_ID` с ID группы Telegram.
  Переменные `VITE_TELEGRAM_API_ID` и `VITE_TELEGRAM_API_HASH` зарезервированы для будущей интеграции с TDLib и в текущей версии не требуются.
  Для просмотра чатов используется страница `/chats`. Перед запуском выполните `scripts/setup_tdweb.sh`, чтобы скопировать файлы TDLib в `bot/web/public/tdlib`.
  Для продакшена обязательно измените переменные `ADMIN_EMAIL` и `ADMIN_PASSWORD`
  на собственные значения: по умолчанию указаны `admin@example.com` и `123456`.
  Подключение к MongoDB выполняет `bot/src/db/connection.js`,
  обеспечивающий единый пул соединений. Начиная с `mongoose` 8
  использование опций `useNewUrlParser` и `useUnifiedTopology`
  не требуется, поэтому они удалены из конфигурации, чтобы
  исключить предупреждения драйвера.
   Пользователи бота хранятся отдельно в коллекции `telegram_users`,
   что устраняет ошибку дублирующего индекса `email_1` в базе.

#### Основные переменные окружения

| Переменная | Описание |
|------------|----------|
| `BOT_TOKEN` | Токен Telegram-бота |
| `CHAT_ID` | ID чата для уведомлений |
| `ADMIN_EMAIL` | Email администратора |
| `ADMIN_PASSWORD` | Пароль администратора |
| `MONGO_DATABASE_URL` | Строка подключения MongoDB |
| `APP_URL` | HTTPS-адрес мини‑приложения |
| `BOT_API_URL` | URL локального сервера Bot API |
| `WEBHOOK_URL` | Вебхук для режима webhook |
3. Установите зависимости серверной части:
   ```bash
   npm ci --prefix bot || npm --prefix bot install
   npm audit fix --prefix bot
   # или выполните ./scripts/install_bot_deps.sh
   ```
4. В переменную `CHAT_ID` запишите ID чата для уведомлений. Его можно узнать через бота `@userinfobot`.
5. Запустите контейнеры:

```bash
docker compose up --build
```
По умолчанию приложение слушает порт 3000; при необходимости
измените его через переменную `HOST_PORT` в `.env`.

Compose соберёт образ бота и запустит MongoDB.
Если при сборке возникла ошибка `lstat /bot/client: no such file or directory`,
убедитесь, что команда выполняется из корня репозитория и директория
`bot/web` присутствует.
После команды `/start` бот отправит кнопку «Открыть приложение», поэтому
использование `/app` остаётся опциональным.
Если Telegram возвращает ошибку `BUTTON_TYPE_INVALID`, бот повторит сообщение
с обычной ссылкой на приложение.
Команда `/help` выводит краткое описание всех доступных команд.
Команда `/browser` выдаёт эту ссылку напрямую, что позволяет открыть мини‑приложение во внешнем браузере.
Команда `/create_task <название>` создаёт задачу с указанным заголовком;
если текст после команды отсутствует, бот сообщит о необходимости указать
название.
Команда `/list_tasks` выводит сообщение «Нет задач», если пользователю нечего показать.
Команда `/task_menu` открывает меню с кнопками для просмотра задач и запуска приложения.
Для отправки ссылки на конкретную задачу используйте формат `https://t.me/YourBot?start=task_<id>`.
При переходе по адресу `https://t.me/YourBot?start=invite_<departmentId>` пользователь автоматически
присоединяется к указанному отделу и получает кнопку для входа в мини‑приложение.
После старта через `/start` пользователь получает JWT для доступа к приложению.
Регистрация через веб-интерфейс отключена, проверяется членство в Telegram группе.
Для проверки сервера запросите GET `/health`.
При занятости порта 3000 укажите другой `HOST_PORT` в `.env`.
Чтобы остановить сервисы, выполните `docker compose down`.
При необходимости проверьте подключение к базе скриптом
`scripts/check_db_fetch.cjs`. Он отправит запрос авторизации и создание
тестовой задачи, удаляя её после успешного ответа.
Меню команд Telegram можно обновить через
`scripts/set_bot_commands.sh`, список хранится в `scripts/bot_commands.json`.

### Локальный сервер Telegram Bot API

Для загрузки больших файлов Telegram предоставляет отдельный сервер `telegram-bot-api`.
Проще всего запустить его в Docker:

```bash
docker run --name tg-bot-api -p 8081:8081 \
  -e TELEGRAM_API_ID=<id> -e TELEGRAM_API_HASH=<hash> \
  ghcr.io/telegrammessenger/telegram-bot-api:latest
```

В `.env` установите `BOT_API_URL=http://localhost:8081` и перезапустите контейнер
бота, тогда запросы будут направляться на локальный сервер.
Локальный сервер позволяет скачивать файлы размером до 2 ГБ без ограничений Telegram.


## Миграции и сиды

- `node scripts/db/migrate.js` создаёт индексы в MongoDB
- `node scripts/db/seed.js` наполняет базу тестовыми данными

При необходимости можно собрать единый образ из корневого `Dockerfile`. По умолчанию `docker compose` использует `bot/Dockerfile`. Используется многоступенчатая сборка для уменьшения размера:

```bash
docker build -t task-manager .
docker run --env-file .env -p ${HOST_PORT:-3000}:${PORT:-3000} task-manager
```
Файл `.dockerignore` исключает `.env` и `.env.*`, чтобы переменные не попадали в контекст Docker.

### Пример запроса к API

```bash
curl -X GET http://localhost:3000/api/tasks/123
```

### Развёртывание на [Railway](https://railway.com)

1. Создайте новый проект и подключите репозиторий.
2. Выберите Node `20` или совместимую версию.
3. В настройках задайте переменные из `.env.example`.
4. Railway автоматически использует `Procfile` из корня. В нём теперь выполняется
   сборка интерфейса перед стартом, что предотвращает ошибку `404` на `/dashboard`.
5. Установите CLI для проверки статуса:
   ```bash
   npm install -g @railway/cli
   ```
   При ошибке `connect ENETUNREACH` укажите прокси через `HTTP_PROXY` и `HTTPS_PROXY` либо скачайте архив из GitHub Releases.
   После установки проверьте:
   ```bash
   railway status
   ```
6. Нажмите Deploy и дождитесь запуска контейнера.
7. Если Railway выдаёт `502` на `/bot`, проверьте доступность DNS кластера MongoDB и правильность `MONGO_DATABASE_URL`. Бот выполнит три попытки переподключения.

## Интерфейс

Фронтенд построен на React + Vite + Tailwind и использует элементы из демонстрационного проекта TailAdmin. Стили основаны на проекте [TailAdmin React](https://github.com/TailAdmin/free-react-tailwind-admin-dashboard); архив с примерами удалён из репозитория, поэтому меню и шапка максимально повторяют демо. Помимо разделов Dashboard, Tasks, Logs и Roles добавлена страница `/charts` с примером графика на основе `react-chartjs-2`. Задачи отображаются на странице `/tasks`, оформленной как `task-list` из TailAdmin, есть фильтры по статусу и кнопка добавления. Уведомления выводятся через стек `Toasts`, который может отображать несколько сообщений одновременно. Канбан‑доска использует библиотеку `@hello-pangea/dnd`, совместимую с React 19. Добавлены страницы управления ролями и просмотра логов. График `TasksChart` выполнен в фирменных цветах и автоматически переключается между светлой и тёмной темой. На Dashboard внедрены skeleton‑карточки и плавное появление таблицы задач. Ссылки на исполнителей открывают чат в Telegram через `tg://user?id=<telegram_id>`, позволяя связаться с нужным сотрудником одним кликом. Ссылки на исполнителей открывают чат в Telegram через `tg://user?id=<telegram_id>`, позволяя связаться с нужным сотрудником одним кликом.

## Напоминания о задачах

Планировщик `scheduler.js` запускается вместе с ботом (кроме режима тестирования) и раз в минуту проверяет задачи с полем `remind_at`. Когда срок наступает, бот отправляет напоминание каждому исполнителю из полей `assigned_user_id` и `assignees`, если у пользователя в профиле включена настройка «получать напоминания». Если ответственные отсутствуют либо все отключили напоминания, уведомление отправляется в чат отдела. Периодичность задаётся переменной `SCHEDULE_CRON`. При необходимости его можно остановить функцией `stopScheduler()`.

## Структура проекта

```
project-root/
├── ROADMAP.md          # план разработки
├── CHANGELOG.md        # история версий
├── bot/                # исходный код Telegram-бота
│   └── Dockerfile      # контейнер бота
├── .env.example        # пример переменных
├── .env                # локальные переменные (не добавляйте в git)
├── docker-compose.yml  # локальное развертывание
└── README.md           # документация
```

## Лицензия

Проект распространяется под лицензией MIT.

## Релизы

Релизы формируются автоматически при создании тега `vX.Y.Z`. После публикации можно скачать архив и Docker-образ.

```bash
docker pull agrmcs:vX.Y.Z
```

Или установить через npm:

```bash
npm install agrmcs@vX.Y.Z
```

## CI с Docker

Файл `.github/workflows/docker.yml` проверяет `docker-compose.yml` и собирает образы с помощью `docker compose` при каждом pull request.

## Лучшие практики CI/CD

Надёжный pipeline помогает быстрее доставлять изменения. В базовый набор стоит включить:

- отдельные workflow для тестов, линтера и сборки Docker;
- кеширование `node_modules` и зависимостей фронтенда;
- проверку наличия переменных окружения и генерацию `.env` через `create_env_from_exports.sh`;
- сканирование зависимостей на уязвимости;
- автоматическое исправление найденных проблем командой `npm audit fix` (в том числе через `scripts/install_bot_deps.sh`);
- контроль синхронизации `package-lock.json`, иначе `npm ci` может завершиться ошибкой;
- автоматический деплой на Railway после успешных тестов.
- деплой через Railway CLI в релизном workflow `release.yml`;
- в `ci.yml` бэкенд устанавливает зависимости через `scripts/install_bot_deps.sh`.
- базовый workflow устанавливает зависимости и запускает тесты по push и pull_request на `main`.
- регулярный запуск `npm test --prefix bot` и `npx eslint bot/src`;
- проверку фронтенда командой `npm run lint --prefix bot/web`.
- перед запуском линтера убедитесь, что зависимости фронтенда установлены:
  `npm --prefix bot/web install`.
- линтер использует `@typescript-eslint/parser` и одноимённый плагин,
  что позволяет проверять файлы `**/*.{js,jsx,ts,tsx}`.
- следите за актуальностью `bot/web/package-lock.json`, иначе `docker compose build` завершится ошибкой `npm ci`.
- регулярно обновляйте зависимости, чтобы избежать предупреждений npm об устаревших пакетах (`lodash.isequal`, `lodash.get`, `inflight`, `glob`).
- для устранения сообщения `inflight@1.0.6` использован override `glob@11`, обновите lock-файл через `npm install --prefix bot`.
- подобным образом добавлены override для `rimraf@6` и `uuid@9` в `bot/web/package.json`, что устранило предупреждения о `rimraf@2.6.3` и `uuid@3.4.0`.


## Внесение вклада

Перед разработкой создайте задачу через шаблон в `.github/ISSUE_TEMPLATE` и изучите [CONTRIBUTING.md](CONTRIBUTING.md). При каждом изменении обновляйте документацию и `CHANGELOG.md`.
Основной шаблон теперь называется `task.yml` и содержит поля локации, срока и ответственных лиц.

## Безопасность

Файл `.env` содержит секреты и предназначен только для локальной разработки.
Создайте его на основе `.env.example` и не публикуйте в репозитории.
Для продакшена рекомендуем использовать Docker Secrets или сторонние хранилища
секретов, например [Vault](https://www.vaultproject.io/).
Регулярно выполняйте `npm --prefix bot audit` и обновляйте зависимости при
появлении предупреждений GitHub о безопасности.

## Резервное копирование БД в R2

Для создания архива MongoDB и загрузки его в R2 выполните:

```bash
./scripts/backup_mongo_r2.sh
```

Скрипт использует переменные из `.env` и требует установленный `aws` CLI.

## Загрузка вложений

Отправьте документ или фото с подписью `/upload_file <id>`.
Бот скачает файл через `getFile`, загрузит в R2 и добавит ссылку в задачу.

Отправьте voice или audio сообщение с подписью `/upload_voice <id>`.
Бот загрузит запись в R2 и сохранит ссылку во вложениях задачи.

Send a document or photo with caption `/upload_file <id>`.
The bot downloads the file via `getFile`, uploads it to R2 and saves the link.

Example:

```text
/upload_file 64feabcd1234
```

```text
/upload_voice 64feabcd1234
```

### Ошибка 404 на `/dashboard`

Если в логах появляется ответ `404` на `GET /dashboard/`, значит статический интерфейс не сгенерирован. Выполните сборку фронтенда:

```bash
npm --prefix bot run build-client > /tmp/npm_build.log 2>&1 && tail -n 20 /tmp/npm_build.log
```

Или воспользуйтесь скриптом:

```bash
./scripts/build_client.sh
```

Если команда завершается ошибкой `vite: not found`, сначала установите зависимости:

```bash
npm --prefix bot/web install > /tmp/npm_install.log 2>&1 && tail -n 20 /tmp/npm_install.log
```

Затем повторите сборку. Убедитесь, что каталог `bot/public` содержит статические файлы.
Теперь Vite сразу помещает сборку в `bot/public`, копирование из `web/dist` не требуется.
При пустой директории `bot/public` сервер выполнит сборку сам, но для актуализации интерфейса лучше запускать `npm --prefix bot run build-client` вручную.
Docker автоматически запускает `npm run build-client`, но после изменений фронтенда выполните сборку заново.
После обновления зависимостей повторяйте `npm --prefix bot/web install` и `npm --prefix bot run build-client`.
Для PostCSS используйте плагин `@tailwindcss/postcss`, иначе сборка завершится ошибкой.
Если установка зависимостей блокируется, убедитесь в доступе к интернету или настройте прокси.
Если при установке выводится предупреждение `Unknown env config "http-proxy"`,
замените переменную окружения `http-proxy` на `HTTP_PROXY` или `npm_config_proxy`.
Если в браузере появляется ошибка `Minified React error #130`, чаще всего она вызываетcя попыткой отрисовать компонент `undefined`. Проверьте, что элементы бокового меню содержат свойство `icon`. Также убедитесь в наличии `<div id="root">` в HTML: в `main.tsx` добавлена явная проверка и сообщение об его отсутствии.

## Обзор текущего состояния

### Плюсы

- Чёткая бизнес-логика агро-операций и пользователей, REST API доступен сразу.
- Проект докеризирован, запуск происходит быстро через `docker-compose`.
- Пример `.env` и руководство по развёртыванию входят в репозиторий.
- Код разделён на слои: роуты, модели, сервисы.
- Фронтенд переписан на React + Vite и Tailwind.
- Все оставшиеся компоненты переведены на TypeScript, в каталоге `bot/web/src` не осталось `.jsx` файлов.
- Tailwind настроен по образцу TailAdmin 1.3, добавлены шрифты Inter, Poppins и Roboto.
- Удалена нестандартная директива `@custom-variant dark`, из-за которой esbuild выдавал предупреждения при минификации CSS.
- Для стабильной сборки обновлён плагин `@tailwindcss/postcss` до версии 4.1.11.
- Админ‑панель подключена к API и отображает задачи из MongoDB.
- Добавлены страницы "Проекты", "Отчёты", "Роли", "Логи", "Админ" и "Профиль".
- На этих страницах реализованы формы: добавление пользователей, создание проектов, создание ролей и фильтрация отчётов.
- Страница `Роли` оформлена в стиле TailAdmin: форма создания и список ролей размещены в аккуратных карточках.
- Пользователям можно назначать роли, а доступ к маршрутам ограничен middleware `checkRole`.
- Реализована канбан-доска задач на `/tasks/kanban`.
- Исправлена ошибка линтера в компоненте Kanban.
- Статусы задач приведены к `new/in-progress/done`, что исключило ошибки 500 при создании.
- Реализована регистрация пользователей, авторизация через JWT и страница личного кабинета.
- Код подтверждения можно получить по SMS или в Telegram, что снижает затраты на рассылку.
- Страницы входа, регистрации и профиля используют стили TailAdmin.
- Формы авторизации показывают спиннер во время отправки, ошибки выводятся через Toast.
- При создании задачи выводится уведомление об успехе.
- Страница `Tasks` получила оформление TailAdmin: поля ввода и таблица задач используют фирменные цвета и скругления.
- Появилась возможность удалять задачи через API и кнопку "удалить" в списке.
- Команды `/list_tasks` и `/list_all_tasks` показывают кнопки "✔️" и "❌" для
  быстрого завершения или удаления задачи прямо в чате.
- По нажатию на название открывается модальное окно с подробной формой задачи: локация, сроки, описание и комментарий редактируются прямо в окне.
- Кнопка создания задачи теперь называется «Новая задача». Стартовую и финальную точки выбираем через кнопку «Карта» с мини‑окном Google Maps. Пользователь копирует ссылку «Поделиться» и вставляет её без предварительной проверки; адрес извлекается при подтверждении. Можно указать тип задачи и упомянуть исполнителей через `@id` Telegram.
- В окне карты показана подсказка о кнопке «Поделиться». Ссылка проверяется при подтверждении и при ошибке выводится сообщение.
- Форма создания задачи расширена: можно выбрать приоритет, автора, исполнителей и оставить первый комментарий. В текстовых полях поддерживаются упоминания пользователей, групп и ролей.
- Для отсева неверных ссылок применяется утилита `validateURL` на базе пакета `validator`.
- Мини‑карта загружается через ссылку `maps/embed`, поэтому заголовок `X-Frame-Options` не мешает отображению. В `helmet` разрешён `frame-src` для Google и OAuth Telegram.
- Есть скрипт `scripts/check_db_fetch.cjs`, который проверяет подключение к БД и работу API.
- Меню команд бота обновляется через `scripts/set_bot_commands.sh`,
  список хранится в `scripts/bot_commands.json`.
- Запросы к задачам вынесены в модуль `bot/web/src/services/tasks.js`.
- Исправлена ошибка создания задачи через бота: теперь в базу передаётся поле `title` и приоритет по умолчанию "В течении дня".
- Для сокращения размера бандла страницы React загружаются лениво через `React.lazy`.
- Формы добавления пользователей и проектов, а также фильтр отчётов стилизованы под TailAdmin, уведомления отображаются в аккуратных карточках.
- Команды `/assign_task`, `/upload_file` и `/edit_last` проверяют обязательные параметры и выдают ошибку при отсутствии аргументов.
- Команда `/upload_voice <taskId>` прикрепляет голосовое сообщение и сохраняет ссылку в задаче.
- Если указать только id задачи, `/assign_task` отправит кнопку выбора исполнителя через `KeyboardButton.requestUser`. При параметре `group` бот предложит кнопку `KeyboardButton.requestChat` для выбора группы.
- Добавлены недостающие компоненты TailAdmin: адаптивный Sidebar, выпадающее меню профиля, вкладки, пагинация, breadcrumbs и skeleton‑лоадеры.
- Sidebar получил кнопку сворачивания на десктопе и компактный режим с отображением только иконок.
- Исправлено отображение текста событий календаря в тёмной теме.
- В тёмной теме обновлены цвета текста в выпадающих меню, хлебных крошках и вкладках, что улучшило контраст.
- Страницы "Админ", "Проекты" и "Логи" используют карточки TailAdmin и показывают "хлебные крошки" сверху.
- Breadcrumbs добавлены также на Dashboard, страницу профиля и отчётов.
- В шапке появилось выпадающее меню уведомлений с примером одного сообщения.
- При отсутствии токена в шапке отображается ссылка «Войти», иначе меню профиля.
- Drag-and-drop реализован через `@hello-pangea/dnd`, совместимый с React 19.
- Поддерживаются чеклисты задач, учёт времени и KPI‑отчёты.
- Отчёты допускают фильтр по дате через параметры `from` и `to` в `/api/tasks/report/summary` (например, `?from=2024-01-01&to=2024-12-31`).
- Есть пример графиков и компонент `api.ts` для работы с API.
- Через модуль `telegramApi.js` доступны любые методы Telegram Bot API, реализованы `sendPhoto`, редактирование сообщений и inline-режим.
- В inline-режиме поддерживаются команды `add <текст>` для быстрого создания задачи и `search <ключ>` для поиска до десяти задач.
- Бот автоматически регистрирует пользователей и позволяет администраторам управлять списком пользователей и задач.
  Email для таких аккаунтов формируется как `<telegram_id>@telegram.local`, что исключает ошибку MongoDB о дублировании.
- При первой регистрации бот вызывает `verifyUser` и сохраняет дату проверки, статус виден в админ‑панели.
- ESLint проверяет весь серверный код.
- Фронтенд проходит проверку `npm run lint --prefix bot/web` без ошибок.
- Подключён `@typescript-eslint/eslint-plugin`, линтер поддерживает TypeScript.
- Компонент `Admin` переписан на TypeScript, контекст авторизации импортируется
  через `import { AuthContext } from '../context/AuthContext'`.
- Цветовая схема унифицирована: основные акценты `accentPrimary` (#465fff) и
  `accentSecondary` (#7a5af8), нейтральные оттенки `neutral-100/300/500/900`.
- Исправлены предупреждения React Hooks на страницах Dashboard и Tasks.
- Внедрены `helmet` и `cors`, входные данные проверяются через `express-validator`.
- Регистрация и вход теперь валидируют поля через `express-validator`, что предотвращает некорректные запросы.
- Для Express 5 добавлен fallback `app.get('/{*splat}')`, обновление страниц не приводит к `404`.
- Удалены устаревшие маршруты `/tasks`, поэтому при перезагрузке SPA больше не появляется ошибка `{"message":"No token provided"}`.
- Для fallback маршрута настроен rate limit, предотвращающий массовые запросы.
- Запрос `/api/tasks/:id` тоже ограничен (100 в 15 минут), что защищает API.
- Маршруты `/groups`, `/users`, `/roles` и `/logs` работают только через `/api`.
- Статус задач меняется по адресу `/api/tasks/:id/status`.
- Путь `/api/auth/login` принимает не более 5 запросов в минуту и защищён от брутфорса.
- Ограничены обращения к `/api/groups`, `/api/users`, `/api/roles`, `/api/logs` и
  `/api/tasks/:id/status` (100 запросов за 15 минут).
- Автотесты и линтер выполняются без ошибок.
- Добавлены тесты kanbanStatus.test.js и authRole.test.js для проверки статуса и ролей.
- Добавлены тесты commandValidation.test.js, проверяющие отсутствие аргументов в
  `/edit_last`, `/assign_task` и `/upload_file`.
- Команда `/upload_file <taskId>` принимает документ или фото и сохраняет ссылку в задаче.
- Регулярно обновляются ключевые зависимости, например `@aws-sdk/client-s3` и `jest`.
- При ошибке запроса профиля токен автоматически удаляется из `localStorage`,
  что предотвращает бесконечные 401 и перенаправляет пользователя на форму входа.
- При ответе 401 или 403 на `/api/tasks` страница `Tasks` тоже ведёт на `/login`.
  - Добавлена страница входа `/login` с виджетом Telegram Login. После успешной
    авторизации сервер выдаёт JWT и сохраняет его в `localStorage`.
  - Виджет обновлён до версии 22, используется параметр `data-request-access="write"`.
  - В настройках `helmet` разрешены директивы `script-src https://telegram.org 'unsafe-eval'`
    и `media-src data:`, поэтому виджет загружается без ошибок CSP.
  - После создания задачи в мини‑приложении вызывается `window.Telegram.WebApp.sendData('task_created:<id>')`.
    Бот получает событие `web_app_data` и отправляет подтверждение пользователю.
  - `/create_task` создаёт обсуждение через `createForumTopic` и сохраняет `telegram_topic_id`. В интерфейсе задачи появляется ссылка на этот топик.

### Минусы

- Части бизнес‑логики ещё требуют доработки.

### Как улучшить

- Продолжать покрывать тестами новую функциональность.
- Добавлены отдельные тесты для безопасности и проверки лимитов запросов.
- Регулярно выполнять `npm audit` и при обнаружении проблем запускать `npm audit fix` (используйте `scripts/install_bot_deps.sh` или `scripts/audit_dependencies.sh`).
 - Автоматический деплой на Railway осуществляется через workflow `release.yml`.

Эти шаги позволят ускорить развитие проекта.

### Итог

Проект представляет готовую базу и быстро разворачивается, но требует модернизации для полноценного продакшна. Интерфейс построен на React + Vite + Tailwind и использует элементы TailAdmin. В Dashboard теперь есть KPI‑карточки, график активности и таблица последних задач. Данные берутся из API через защищённые маршруты. При создании задач выводится уведомление. Код фронтенда форматируется Prettier.
С недавним обновлением стили синхронизированы с репозиторием TailAdmin, что приблизило внешний вид к демо TailAdmin.


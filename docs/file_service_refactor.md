<!-- Назначение файла: описание обновлённой архитектуры файлового сервиса, модулей storage и tasks. -->

# Файловый сервис ERM-Bot: новая архитектура

## Задачи и ограничения

- Обеспечить привязку файлов к задачам, пользователям и правам доступа.
- Сохранить возможность локального хранения с последующей миграцией в облако.
- Предотвратить прямой доступ к вложениям вне контекста задачи.
- Согласовать API с текущей серверной архитектурой и UI Telegram/Web клиента.

## Модель данных

### Новая коллекция `files`

| Поле        | Тип          | Описание                                           |
|-------------|--------------|----------------------------------------------------|
| `_id`       | ObjectId     | Уникальный идентификатор файла.                   |
| `taskId`    | ObjectId     | Ссылка на задачу, используется для индексов.      |
| `uploaderId`| ObjectId     | Пользователь, загрузивший файл.                   |
| `name`      | string       | Оригинальное имя файла.                           |
| `path`      | string       | Относительный путь в каталоге `STORAGE_DIR`.      |
| `type`      | string       | MIME-тип, определяет предпросмотр.                |
| `size`      | number       | Размер в байтах, проверяется при загрузке.        |
| `hash`      | string       | Контрольная сумма для повторных загрузок.         |
| `uploadedAt`| Date         | Метка времени загрузки.                           |
| `meta`      | object       | Дополнительные атрибуты (например, превью).       |

- Индексы: `taskId` (многопольный), `uploaderId`, `hash` (уникальный по задаче).
- Каскадное удаление: хук задачи удаляет связанные файлы и физические объекты.
- Физическое хранение: `STORAGE_DIR/uploads/<taskId>/<hash>`.

### Изменения в задачах

- Поле `files` хранит массив `ObjectId`, синхронизируется сервисом `dataStorage`.
- Журнал `history` фиксирует операции `file.upload`, `file.delete`.

## Слои backend

### HTTP-контроллер `storage.controller.ts`

- `POST /api/v1/tasks/:taskId/files`
  - Принимает `multipart/form-data`.
  - Проверяет принадлежность пользователя к задаче (creator/executor/observer или admin).
  - Делегирует сохранение `storageService.upload`.
  - Возвращает JSON с метаданными и флагом `canDelete`.
- `GET /api/v1/tasks/:taskId/files`
  - Возвращает массив метаданных.
  - Используется при открытии карточки задачи.
- `GET /api/v1/files/:fileId/download`
  - Отдаёт поток файла после проверки прав.
- `DELETE /api/v1/files/:fileId`
  - Доступно автору файла, создателю задачи и администраторам.
  - Удаляет запись и файл из файловой системы.

### Сервисный слой `storageService`

- Методы: `upload`, `listByTask`, `download`, `remove`.
- Выполняет валидацию (`MAX_FILE_SIZE`, проверка расширений, антивирус).
- Сохраняет файл во временный каталог, прогоняет через антивирус, затем переносит в `STORAGE_DIR`.
- Логирует операции в общий журнал и метрику `storage_operations_total{action}`.

### Интеграция с задачами

- `taskService` получает список файлов через `storageService.listByTask`.
- При удалении задачи `taskService` вызывает `storageService.removeByTask`.
- Middleware валидации прав доступа использует общую функцию `checkTaskParticipant(user, task)`.

## Авторизация и аутентификация

1. JWT берётся из HttpOnly cookie (уже реализовано). Контроллер извлекает `userId` и глобальный `access`.
2. Загружает задачу по `taskId` и вычисляет набор участников: creator, executor, observers.
3. Проверяет роль: участник задачи или `access >= ADMIN_MASK`.
4. При несоответствии — ошибка 403 и запись в лог безопасника.
5. Для удаления проверяется `file.uploaderId === userId` или `userId === task.creatorId` или admin.

## API для фронтенда

### REST

- `GET /api/v1/tasks/:taskId/files`
- `POST /api/v1/tasks/:taskId/files`
- `DELETE /api/v1/files/:fileId`
- `GET /api/v1/files/:fileId/download`

### GraphQL (по необходимости)

```graphql
scalar Upload

type File {
  id: ID!
  taskId: ID!
  name: String!
  type: String!
  size: Int!
  uploadedAt: DateTime!
  uploadedBy: User!
  canDelete: Boolean!
}

type Task {
  files: [File!]!
}

mutation uploadFile(taskId: ID!, file: Upload!): File!
mutation removeFile(fileId: ID!): Boolean!
```

- Загрузку крупных файлов целесообразно оставить на REST, GraphQL отдаёт метаданные.
- Subscriptions `fileAdded`/`fileRemoved` подключаются на втором этапе.

## UI и UX

1. Раздел «Файлы» на странице задачи, таблица колонок: Название, Тип, Размер, Загрузил, Дата, Действия.
2. Превью изображений через параметр `?thumb=true`, генерируется lazy.
3. Drag-and-drop зона + мультизагрузка с прогрессом.
4. Кнопки «Скачать» (всегда) и «Удалить» (при `canDelete`).
5. Ограничения по размеру и типу отображаются до начала загрузки.
6. Уведомление в UI и Telegram-боте после успешного добавления.

## Поток загрузки

1. Пользователь выбирает файл, фронтенд отображает запись со статусом `pending`.
2. Фронтенд отправляет `POST /tasks/:taskId/files`, отслеживает прогресс (XHR events).
3. Сервер сохраняет файл, создаёт запись в коллекции, возвращает метаданные.
4. UI обновляет строку, снимает статус `pending` и показывает кнопки действий.
5. Остальные клиенты получают обновление (через WebSocket или повторный запрос).

## Миграция

1. Добавить коллекцию `files` и индексы (`scripts/db/ensureIndexes.ts`).
2. Обновить `dataStorage` и связанные сервисы задач.
3. Переписать существующие endpoints загрузки на новый контроллер.
4. Перенести исторические данные: считать записи из старого хранилища и заполнить коллекцию `files`.
5. Добавить e2e-сценарии: загрузка автором, просмотр исполнителем, блокировка постороннего пользователя.
6. Обновить документацию (`docs/technical_manual.md`, `docs/architecture.md`).

## Эволюция

- При росте нагрузки заменить локальное хранилище на S3-совместимое, сохранив интерфейс `storageService`.
- Ввести ретеншн-политику и пометку `expiresAt` для временных файлов.
- Расширить антивирус ClamAV и уведомления об инцидентах.
- Добавить отчёты по использованию хранилища в `/cp/storage`.

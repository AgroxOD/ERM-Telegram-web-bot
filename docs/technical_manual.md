<!-- Назначение файла: объединённое техническое руководство для проекта. Основные модули: bot, web, scripts. -->

# Технический мануал

Этот документ собирает в одном месте всю информацию по настройке и запуску проекта. Предыдущие файлы `docs/*.md` оставлены для истории, но все основные сведения сведены здесь.

## Архитектура

Проект состоит из сервера и мини‑приложения React внутри каталога `bot`.

- `src/api` — Express API с подключением Swagger и лимитом запросов.
- `src/bot` — Telegram‑бот на Telegraf и планировщик напоминаний.
- `src/routes` — REST‑маршруты.
- `src/services` — работа с Telegram API и MongoDB.
- `src/models`, `src/db` — схемы Mongoose и подключение к базе.
- `web` — клиентская часть React с собственными контекстами.
- Контейнер собирается через `Dockerfile` в корне репозитория.
  Отдельный `bot/Dockerfile` удалён за ненадобностью.

### Инъекция зависимостей

Сервисы регистрируются через библиотеку `tsyringe` в файле `bot/src/container.ts`.
Точка входа `src/server.js` подключает контейнер перед запуском API.

### Сборка TypeScript

Перед запуском сервер компилируется командой `npm --prefix bot run build`. Все
файлы из `bot/src` копируются в каталог `dist`, а затем стартует `node dist/server.js`.

### Схема модулей

Диаграмма зависимостей и связи компонентов приведены в файле
`docs/architecture.md`. Она демонстрирует роль сервисов между API, ботом и
клиентом.

## Маски доступа

Роль пользователя описывается числовой маской в поле `access`:

- `1` — обычный пользователь.
- `2` — администратор.

Функция `hasAccess` из `bot/src/utils/accessMask.js` проверяет права. Для маршрутов введены `Roles` и `rolesGuard`,
которые задают и проверяют маску доступа пользователя.

## Основные маршруты API

Полный список маршрутов доступен через Swagger по адресу `/api-docs` после запуска сервера. Ниже перечислены базовые эндпойнты:

| Метод | Путь                     | Назначение                  |
| ----- | ------------------------ | --------------------------- |
| GET   | /health                  | Проверка сервера            |
| POST  | /api/v1/auth/send_code   | Отправить код подтверждения |
| POST  | /api/v1/auth/verify_code | Подтвердить код             |
| GET   | /api/v1/tasks            | Список задач                |
| POST  | /api/v1/tasks            | Создать задачу              |
| PATCH | /api/v1/tasks/:id        | Обновить задачу             |

Более подробная карта запросов приведена в разделе "Карта запросов".

Валидация входных данных выполняется через классы DTO в каталоге `src/dto`.
Middleware `validateDto` подключает правила из метода `rules` и возвращает
ошибку 400 при несоответствии.
Для простых роутов создана функция `utils/validate.js`,
которая собирает правила `express-validator` и отправляет ошибку при неуспехе.
Она экспортирует `handleValidation` для повторного использования в контроллерах,
избавляя от дублирования кода.

## Защита от CSRF

API использует middleware `lusca.csrf`. Токен сохраняется в `localStorage`
и передаётся в заголовке `X-XSRF-TOKEN`. Для получения токена предусмотрен
маршрут `GET /api/v1/csrf`, который устанавливает cookie и возвращает значение
в поле `csrfToken`. Мини‑приложение вызывает его при запуске, сохраняет токен
в `localStorage` и вставляет в заголовок. Если токен отсутствует,
`authFetch` получает его перед запросом.
При возврате вкладки в фокус AuthProvider повторно запрашивает `/api/v1/csrf`.
Cookie `token` и сессия используют флаг `SameSite=Lax`. В продакшене домен
берётся из `COOKIE_DOMAIN` либо из `APP_URL`. В разработке домен не задаётся,
чтобы сохранить работоспособность на localhost.
`COOKIE_DOMAIN` может быть полным URL, из которого берётся hostname. Неверное
значение приведёт к ошибке при старте сервера.
Сессионная cookie имеет срок жизни семь дней, что совпадает с временем действия JWT.
Cookie `XSRF-TOKEN` задаётся с тем же доменом и также имеет `SameSite=None`.
authFetch повторяет запрос при ответе 403 даже без JSON
Каждый POST‑запрос через `authFetch` добавляет заголовок `X-XSRF-TOKEN`
из значения в `localStorage`.
При запросе `/api/v1/csrf` сервер также создаёт cookie `connect.sid` с
идентификатором сессии. Эту cookie нужно передавать вместе с `XSRF-TOKEN`, иначе проверка не пройдёт.
Маршрут `/api/v1/optimizer` исключён из проверки CSRF, чтобы проще вызывать его из скриптов. Маршрут `/api/v1/maps/expand` также не требует токена.
Запросы с заголовком `Authorization` обходят проверку CSRF, так как не используют cookie. Переменная `DISABLE_CSRF=1` полностью отключает middleware и выводит предупреждение в продакшене.
Ошибки проверки увеличивают счётчик `csrf_errors_total` и
фиксируются в логах с указанием заголовка и cookie. Логи собирает движок WG Log Engine,
просмотреть их можно на странице `/cp/logs`. Схема MongoDB принимает уровни `debug`, `info`, `warn`, `error` и `log`,
уровни подсвечены цветом,
ошибки могут дублироваться в Telegram. Интерфейс логов строит таблицу с методом, статусом и endpoint,
умеет фильтровать по уровню, дате, тексту и признаку `no-csrf`, поддерживает экспорт в CSV/JSON, live и постраничный просмотр.
Метрику `csrf_errors_total` стоит подключить к Prometheus и настроить оповещение на резкий рост. Пример правила приведён в `prometheus/alert.rules.yml`.
Дополнительно счётчик `api_errors_total` фиксирует ответы с кодами 4xx и 5xx.
Логи содержат IP клиента и заголовок User-Agent для поиска проблем.
Middleware `logging.ts` выводит IP и User-Agent в логах.
Middleware `checkRole` и `checkTaskAccess` записывают отказ доступа с указанием пользователя и IP.
Фильтр по уровню допускает только перечисленные значения.
Каждый успешный вход пользователя фиксируется в логах движком WG Log Engine.

Тест `routeCsrf.test.js` использует secure cookie и проверяет CSRF,
`taskFields.test.js` помогает контролировать валидность полей формы.

## Получение и обновление токенов

1. Клиент при открытии приложения запрашивает `/api/v1/csrf`, чтобы
   получить токен и установить cookie `XSRF-TOKEN`.
2. Затем выполняется `/api/v1/auth/send_code` и `/api/v1/auth/verify_code`,
   после чего сервер выставляет cookie `token` и возвращает JWT в теле
   ответа.
3. При истечении срока жизни или ошибке 401/403 функция `authFetch`
   повторно запрашивает `/api/v1/csrf` и по умолчанию перенаправляет на `/login`.
   Опция `noRedirect` отключает этот переход и возвращает ответ вызывающему коду.
4. Для защиты от XSS cookie `token` имеет флаги `HttpOnly` и `SameSite=Lax`. В продакшене добавляется `Secure` и используется домен из `COOKIE_DOMAIN` либо `APP_URL`. В режиме разработки cookie передаётся и по HTTP без явного домена. Токен живёт семь дней.
5. Middleware `verifyToken` продлевает cookie `token` при каждом запросе,
6. Отдельная функция `setTokenCookie` устанавливает cookie `token` во всех контроллерах
   обеспечивая бесшумное обновление.

### Смешанное хранение CSRF-токена

Токен авторизации `token` передаётся в cookie HttpOnly, а CSRF-токен
хранится на клиенте. В обычной ситуации значение записывается в
`localStorage`, но при недоступности хранилища используется переменная в
памяти, что позволяет продолжить работу до перезагрузки. Утилита
`authFetch` подставляет токен в заголовок `X-XSRF-TOKEN` и при ответе 401/403
получает новый через `/api/v1/csrf`.

## Карта запросов

Базовые функции взаимодействуют с MongoDB и API следующим образом:

| Операция            | Функция              | Маршрут                         |
| ------------------- | -------------------- | ------------------------------- |
| Создать задачу      | `createTask()`       | POST `/api/v1/tasks`            |
| Получить задачи     | `getTasks()`         | GET `/api/v1/tasks`             |
| Обновить задачу     | `updateTask()`       | PATCH `/api/v1/tasks/:id`       |
| Изменить статус     | `updateTaskStatus()` | POST `/api/v1/tasks/:id/status` |
| Массовое обновление | `bulkUpdate()`       | POST `/api/v1/tasks/bulk`       |

Команды бота вызывают те же функции через сервисы в `src/services`.
Функция `updateTask()` фильтрует поля обновления и игнорирует ключи, начинающиеся с `$`.
Контроллеры задач проверяют, что пользователь может изменять только созданные им или назначенные задачи.

## Настройка Telegram‑бота

1. Получите токен у [@BotFather](https://t.me/BotFather) и сохраните в `.env` как `BOT_TOKEN`.
2. Запустите `./scripts/set_bot_commands.sh`, чтобы зарегистрировать команды бота.
3. Для установки текстов сообщений выполните `./scripts/set_bot_messages.sh`.
4. Мини‑приложение можно открыть по команде `/task_form_app`.

Бот разворачивает короткие ссылки Google Maps и сохраняет координаты задачи. После создания задачи из мини‑приложения отправляется событие `task_created` через `Telegram.WebApp.sendData`.
Общие функции формирования ссылок и извлечения координат вынесены в `bot/shared/mapUtils.js` и используются сервером и клиентом. Веб‑клиент импортирует модуль как `import mapUtils from '../../../shared/mapUtils.js'`.

## Проверка initData WebApp

Перед выдачей токена сервер проверяет строку `initData`, полученную от Telegram. Подпись рассчитывается алгоритмом HMAC‑SHA256 с ключом `BOT_TOKEN`. Если подпись не совпадает, запрос отклоняется.

## Развёртывание и запуск

- Локальная разработка начинается с создания `.env` через `./scripts/create_env_from_exports.sh`.
- Зависимости сервера и клиента устанавливаются скриптом `./scripts/install_bot_deps.sh`.
- Тесты и статический анализ запускаются `./scripts/setup_and_test.sh`.
- Перед коммитом Husky запускает `lint-staged`, используйте файл `.husky/_/husky.sh`.
- В тесты входит сценарий `loginFlow.test.js`, эмулирующий полный цикл логина и запрос к защищённому маршруту.
- Тест `loginRouteFlow.test.js` проверяет получение CSRF-токена и вызов `/api/v1/route`.
- Тесты `authService.test.js` и `tasksService.test.js` покрывают логику модулей авторизации и задач.
- Для проверки зависимостей выполните `./scripts/audit_deps.sh`.

### Быстрый старт

```bash
./scripts/create_env_from_exports.sh
./scripts/install_bot_deps.sh # устанавливает все зависимости
npm --prefix bot run dev
```

Пошаговое развертывание на Railway:

1. Создайте проект и подключите плагин **MongoDB**.
2. Задайте переменные `BOT_TOKEN`, `MONGO_DATABASE_URL`, `APP_URL`, `ROUTING_URL` и `VITE_ROUTING_URL`. Переменные `LOG_LEVEL`, `LOG_TELEGRAM_TOKEN` и `LOG_TELEGRAM_CHAT` можно не задавать. Значения `GATEWAY_API_KEY` и `GATEWAY_SENDER` более не требуются.
3. Railway использует `Procfile`, который собирает клиент и запускает pm2.
4. Убедитесь, что приложение слушает `process.env.PORT` на адресе `0.0.0.0`.

### Сервис маршрутов OSRM

Для расчёта маршрутов может использоваться собственный сервис OSRM.

```bash
docker build -t osrm-odessa .
docker run -d -p 5000:5000 osrm-odessa
```

Переменные `ROUTING_URL` и `VITE_ROUTING_URL` должны указывать на адрес сервиса.

## Профилирование и нагрузка

Скрипт `profiling/profile.py` запускает cProfile и делает серию запросов к API:

```bash
python profiling/profile.py
```

Для стресс‑тестов используется Locust:

```bash
locust -f loadtest/locustfile.py --host http://localhost:3000
```

## Метрики Prometheus и Chaos testing

Эндпойнт `/metrics` отдаёт данные prom-client. Отдельный middleware
`metrics.ts` считает `http_requests_total` и `http_request_duration_ms`.
Для сбора метрик используется Prometheus. Конфигурация хранится в
`prometheus/prometheus.yml`, правила оповещений — в `prometheus/alert.rules.yml`.

Запуск Prometheus локально:

```bash
docker run -d -p 9090:9090 \
  -v $(pwd)/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

После старта откройте <http://localhost:9090> и добавьте правила из
`prometheus/alert.rules.yml`.

Для испытаний устойчивости можно запустить `npm --prefix bot run chaos`.

## Интерфейс админки

Веб‑интерфейс построен на TailAdmin. Советы по стилизации собраны в `extended_tailadmin_guide.md`. Цветовые палитры определены в Tailwind, компонентные примеры приведены в файлах `bot/web`.
Для неавторизованных пользователей админки используется статичная заглушка `admin-placeholder.html`; устаревший компонент `AdminPlaceholder.tsx` удалён.

## Ответы бота

Типовые сообщения собраны в `bot/src/messages.js` и перечислены в `docs/bot_responses.md`. При необходимости их можно обновить скриптом `set_bot_messages.sh`.

---

Дополнительный план внедрения рекомендаций после аудита хранится в файле `docs/apply_analysis_plan.md`.
Для подробностей обратитесь к исходным файлам в каталоге `docs/` или истории изменений в `CHANGELOG.md`.

- Лишняя зависимость bcrypt удалена
- Дублирование расчёта маршрутов устранено: добавлена функция applyRouteInfo
- Удалён пакет @aws-sdk/client-s3
- API сжимает ответы через middleware `compression`
- Фильтры логов имеют атрибуты `aria-label`

Предложение по поэтапному плану реализации
Исходя из анализа, оптимальным подходом будет разделить внедрение улучшений на несколько этапов – чтобы параллельно поддерживать стабильность и добавлять новый функционал:
Этап 1: Усиление стабильности и технический долг (ближайшее время). Начать с внутренних улучшений, которые не сильно видны пользователю, но заложат фундамент для дальнейшего роста:
Завершить рефакторинг TypeScript-миграции: убедиться, что все ключевые участки кода типизированы (включая контроллеры Express и функции бота) и что в проекте больше нет any (к счастью, noImplicitAny уже включен, а правило ESLint no-explicit-any снова активировано
GitHub
). Если где-то были допущены временные @ts-ignore, планомерно их устранить, заменив на корректные типы.
Провести ревизию DI-контейнера: определить, какие классы/сервисы можно описать интерфейсами, и зарегистрировать их с именованными токенами. Удалить использование контейнера как сервис-локатора (где сервисы запрашиваются по string-ключам из произвольных мест) – вместо этого внедрять зависимости через конструкторы (благо tsyringe это позволяет). Это сделает структуру зависимостей явной.
Удалить дублированный код и модули. В roadmap упомянуто удаление дублирующего модуля services/tasks.ts
GitHub
– проверить, что таких случаев больше нет (видимо, оставался старый файл после рефакторинга). Убедиться, что логика не продублирована между ботом и API: например, формирование текста задачи есть и в боте (для сообщения) и в API (для ответа) – может, стоит вынести общее в утилиты, чтобы избегать рассинхрона.
Улучшить обработку ошибок в API: уже внедрен общий error handler с форматом Problem Details
GitHub
. Можно расширить собственные классы ошибок (например, NotFoundError, ValidationError) и использовать их в сервисах, чтобы error handler мог возвращать более семантичные сообщения. Это упростит отладку и интеграцию (клиенту будет понятно, что за ошибка).
Расширить прикладные тесты: покрыть тестами максимум бизнес-логики. В первую очередь, критические пути: авторизация (уже протестирована), создание/редактирование задач, права доступа (проверить, что обычный пользователь не может сделать admin-действие через API), генерация маршрутов (можно замокать OSRM и проверить логику кеширования/инвалидирования). Включить тесты на краевые случаи: очень длинное описание (проверить обрезку на 4096 символов
GitHub
), отсутствие обязательных полей, неверные типы – API должен корректно реагировать.
Настроить CI: убедиться, что pipeline запускает все необходимые тесты (unit, integration, e2e). Можно временно сделать e2e-тесты опциональными (чтобы не тормозили каждый коммит), но перед релизом их обязательно прогонять. Добавить сбор метрик coverage в CI (например, использовать jest --coverage и загружать отчёт в сервис вроде Codecov – или хотя бы выводить процент).
Обновить ROADMAP и technical_manual с учётом выполненного на этапе. Например, зафиксировать, что Command/Strategy в работе, какие рефакторинги сделаны.
Результат этапа 1: кодовая база очищена от оставшихся технических долгов, все процессы автоматизации отлажены. Проект готов для безопасного добавления крупных новых фич без угрозы нарушить существующий функционал.
Этап 2: UX-улучшения и базовый браузерный режим (ближайшие 1-2 месяца). На этом этапе фокус на видимых улучшениях для пользователей:
Канбан-доска задач реализована: есть переключатель "Таблица/Доска", перетаскивание меняет статус через PATCH `/tasks/:id/status`. Остаётся оценить права доступа для обычных пользователей и возможность упрощённой версии в Telegram WebApp.
Добавить календарный вид. Если данных о сроках мало, календарь может быть не первостепенным. Однако, можно реализовать хотя бы отображение дедлайнов. Например, вывести небольшой календарь сбоку, где числа отмечены, на какие даты есть задачи, и при клике – список задач за этот день. Более сложную реализацию (drag&drop задач на календарь для смены даты) можно запланировать на потом. Главное – дать возможность визуально видеть нагрузку по дням.
Улучшить форму создания/редактирования задач с точки зрения UX: убедиться, что порядок полей логичен (в roadmap указано, что поле "Название" переместили вверх
GitHub
, а некоторые поля совмещены в одну строку для компактности – это хорошо). Можно добавить автосохранение черновика задачи: если пользователь начал вводить данные и случайно закрыл форму, чтобы они не потерялись (например, хранить временно в localStorage). Добавить предупреждение при выходе со страницы, если форма не сохранена.
Обогащение текстового редактора. Уже интегрирован React Quill для описания задачи
GitHub
, что позволяет форматировать текст. Нужно протестировать, как это сочетается с Telegram (бот в чате, вероятно, показывает markdown-версию описания). Стоит настроить ограничение, какие теги можно использовать, чтобы не сломать вывод в Telegram. Возможно, пригодится функция предпросмотра, как описание будет выглядеть в телеграме (потому что не все форматирование Quill напрямую ляжет в Markdown). Тем не менее, сам факт наличия WYSIWYG-редактора – большой плюс для UX. Можно расширить его, добавив кнопки вставки ссылок, списков, и т.д., если еще нет.
Локализация интерфейса. Если принято решение о мультиязычности, начать реализацию именно на этапе UX-улучшений. Например, подготовить англоязычный пакет локализации параллельно. Это может потребовать времени на перевод всех строк, но делать лучше постепенно. В техническом плане – внедрить библиотеку react-i18next и обернуть приложение в I18nextProvider. Затем заменить статические тексты на ключи. Начать хотя бы с двух языков (ru/en) и переключателя в UI.
Onboarding и подсказки. Разработать небольшие справочные материалы прямо в интерфейсе. Например, иконку “?” в углу, при нажатии на которую показываются советы (можно оформить как модальное окно с краткой инструкцией или тур по элементам интерфейса). Это особенно актуально, если добавляются новые функции (доска, календарь) – чтобы пользователи поняли их ценность и как ими пользоваться.
Обратная связь от пользователей. В интерфейс можно встроить механизм сбора фидбэка – например, форму “Сообщить о проблеме или предложении”. Письма могут отправляться разработчикам либо сохраняться в базу/таблицу. Это поможет узнавать, что реально удобно/неудобно пользователям, и направлять дальнейшие улучшения UX.
Параллельно с UX-улучшениями, закрепить браузерный режим:
Сделать полноценную страницу Login для браузера, где пользователь может ввести телефон и код подтверждения. Доработать backend, чтобы при открытии в браузере без токена сервер не редиректил сразу на Telegram, а позволял проходить эту форму.
После логина обеспечить доступ ко всем разделам: например, в шапке браузерной версии отобразить меню навигации (задачи, маршруты, админка и пр.). Кстати, часть админских страниц (/cp/roles, /cp/logs) сейчас отделены – нужно проверить, что они открываются в браузере корректно. Возможно, стоит объединить мини-приложение и админку в единый интерфейс с условным рендерингом (для админа – показывать пункты админки, для обычного – нет). Это упростит поддержку единого SPA вместо двух.
Начать реализацию кастомизационных настроек: например, страница /cp/settings для администратора, где он может изменить какие-то параметры UI. На этапе 2 можно ограничиться переключателем темы (светлая/тёмная) и, скажем, загрузкой логотипа организации (если вместо названия приложения захочется ставить картинку). Загрузка логотипа – простая функция: в Settings UI -> загрузить файл -> API сохраняет URL (либо сам файл в базе/GridFS) -> приложение показывает его в углу вместо текста.
Подготовить инфраструктуру для дальнейшей кастомизации: решить, где хранить настраиваемые параметры (вероятно, новая коллекция settings в MongoDB, или в документе Organization если концептуально). Прописать на клиенте контекст/хук, который будет эти настройки загружать при старте приложения и применять (например, класс темы, путь к логотипу и т.д.).
Результат этапа 2: Пользователи получают заметно более удобный и красивый интерфейс. Администраторы могут открывать систему прямо в браузере, входить и выполнять все действия, что и в Telegram, а также видят новые инструменты (канбан, фильтры, настройки). Это повысит удовлетворенность текущих пользователей и сделает продукт привлекательнее для потенциальных новых клиентов.
Этап 3: Продвинутые функции и адаптация к рынку (долгосрочная перспектива). После наведения порядка и улучшения UX можно переходить к более крупным функциональным обновлениям, которые поставят продукт на один уровень с коммерческими аналогами:
Расширяемость и интеграции. Открыть API для интеграций с другими системами или предоставить вебхуки. Например, по событию создания или изменения задачи отправлять POST-запрос на указанный URL (настраиваемый в Settings) – это позволит внешним системам реагировать (такое требуется, если, скажем, компания хочет связать наш таск-трекер со своей CRM). Аналогично, можно интегрировать входящие вебхуки – чтобы из внешней системы создавать задачи (нужна авторизация по токену). Это шаг в сторону платформенности, что увеличит ценность продукта в экосистеме.
Дополнительные модули. Проанализировать, какие функции предлагают конкуренты (например, модуль аналитики: отчёты по выполненным задачам, эффективность исполнителей). У нас уже есть KPI-эндпоинт /api/v1/tasks/report/summary – можно на его основе в веб-интерфейсе сделать раздел "Отчёты" с графиками: сколько задач создано/выполнено за период, среднее время выполнения, и т.п. Также упоминалось расширение модели задачи для логистики, закупок
GitHub
– возможно, предстоит добавить новые поля или типы задач. Эти новые модули надо внедрять аккуратно, сохраняя общую стабильность системы.
Оптимизация маршрутов и логистика. Если задача связана с маршрутами, можно внедрить более сложные алгоритмы оптимизации (в roadmap отмечена оптимизация для 1–3 машин, режимы angle или trip
GitHub
уже реализованы). В будущем можно добавить, к примеру, расчет областей охвата, расчет времени прибытия и пр. Но это узкоспециализированные улучшения, их делать по мере требований пользователей.
Мобильное приложение? Хотя сейчас ставка на Telegram Mini App + Web, нельзя исключать, что в какой-то момент может понадобиться отдельное мобильное приложение (например, для работы вне Telegram, с офлайн-режимом). Поскольку у нас уже есть API и веб-клиент, технологии позволяют относительно легко создать React Native или Flutter приложение, используя те же API. Это не план непосредственного будущего, но стратегически – быть готовыми, что продукт может эволюционировать и в standalone приложение, если это потребуется рынку.
Больше кастомизации для админа. Продолжить работу по предоставлению админу контроля: например, конструктор форм – крайне желанная фича во многих системах, когда админ может добавлять пользовательские поля к задачам. Реализовать это непросто (потребуется динамическая схема БД и UI), но постепенно можно идти к этому: сначала дать менять справочники (что будет сделано на этапе 2), потом позволить добавлять простые дополнительные поля (например, поле “Бюджет” типа число, поле “Комментарий клиента” тип текст). Хранить их можно в отдельной коллекции (типа TaskExtra), либо в JSON-поле задачи. UI будет генерировать дополнительные поля на основе конфигурации. Такой уровень гибкости превратит продукт из "фиксированного" в более "настраиваемый", что привлекает продвинутых пользователей.
Усиление аналитики использования. Внедрить сбор анонимной статистики использования функций (с согласия, если open-source проект). Это поможет узнать, какие функции реально используются, а какие нет, и направлять усилия на то, что важно.
Результат этапа 3: Продукт обогащается новыми возможностями, становясь ближе по функционалу к полноценным системам управления задачами (таким как Trello, Asana, Jira в упрощённом виде). При этом сохраняется уникальное преимущество – интеграция с Telegram, что обеспечивает удобство уведомлений и мобильность.
